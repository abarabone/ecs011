#pragma kernel CSMain

AppendStructuredBuffer<uint> cube_instances;


//struct grid
//{
//	uint dotxlines[32][32];
//};
//StructuredBuffer<grid> dotgrids;
StructuredBuffer<uint> dotgrids;


struct CubeXLineBitwise
{
    //uint _98109810;
    //uint _a921a921;
    //uint _ba32ba32;
    //uint _cb43cb43;
    //uint _dc54dc54;
    //uint _ed65ed65;
    //uint _fe76fe76;
    //uint __f870f87;
    uint cubes[8];
};

// あらかじめ共通段階（キューブ手前）までビット操作しておいたほうが速くなるかも、でも余計なエリアにストアするから、逆効果の可能性もある
//CubeXLineBitwise bitwiseCubesXLine_( uint4 y0z0, uint4 y0z1, uint4 y1z0, uint4 y1z1 )
//CubeXLineBitwise bitwiseCubesXLine_(uint y0z0, uint y0z1, uint y1z0, uint y1z1)
CubeXLineBitwise bitwiseCubesXLine_(uint y0z0, uint y0z1, uint y1z0, uint y1z1)
{
    //CubeXLineBitwise blank;
    //if( !any( y0z0 | y0z1 | y1z0 | y1z1 ) ) return blank;

    // fedcba9876543210fedcba9876543210

    const uint m1100 = 0xcccccccc;//0b_11001100_11001100_11001100_11001100u;
    const uint m0011 = m1100 >> 2;
    // --dc--98--54--10--dc--98--54--10
    // dc--98--54--10--dc--98--54--10--
    // fe--ba--76--32--fe--ba--76--32--
    // --fe--ba--76--32--fe--ba--76--32
    const uint y0_dc985410 = y0z0 & m0011 | ( y0z1 & m0011 ) << 2;
    const uint y0_feba7632 = ( y0z0 & m1100 ) >> 2 | y0z1 & m1100;
    const uint y1_dc985410 = y1z0 & m0011 | ( y1z1 & m0011 ) << 2;
    const uint y1_feba7632 = ( y1z0 & m1100 ) >> 2 | y1z1 & m1100;
    // dcdc989854541010dcdc989854541010
    // fefebaba76763232fefebaba76763232
    // dcdc989854541010dcdc989854541010
    // fefebaba76763232fefebaba76763232

    const uint mf0 = 0xf0f0f0f0u;
    const uint m0f = 0x0f0f0f0fu;
    // ----9898----1010----9898----1010
    // dcdc----5454----dcdc----5454----
    // ----baba----3232----baba----3232
    // fefe----7676----fefe----7676----
    const uint _98109810 = y0_dc985410 & m0f | ( y1_dc985410 & m0f ) << 4;
    const uint _dc54dc54 = ( y0_dc985410 & mf0 ) >> 4 | y1_dc985410 & mf0;
    const uint _ba32ba32 = y0_feba7632 & m0f | ( y1_feba7632 & m0f ) << 4;
    const uint _fe76fe76 = ( y0_feba7632 & mf0 ) >> 4 | y1_feba7632 & mf0;
    // 98989898101010109898989810101010
    // dcdcdcdc54545454dcdcdcdc54545454
    // babababa32323232babababa32323232
    // fefefefe76767676fefefefe76767676

    const uint m55 = 0x55555555u;
    const uint maa = 0xaaaaaaaau;
    const uint _a921a921 = ( _ba32ba32 & m55 ) << 1 | ( _98109810 & maa ) >> 1;
    const uint _cb43cb43 = ( _dc54dc54 & m55 ) << 1 | ( _ba32ba32 & maa ) >> 1;
    const uint _ed65ed65 = ( _fe76fe76 & m55 ) << 1 | ( _dc54dc54 & maa ) >> 1;
    const uint __f870f87 = ( _98109810 >> 8 & 0x555555u ) << 1 | ( _fe76fe76 & maa ) >> 1;
    // a9a9a9a921212121a9a9a9a921212121
    // cbcbcbcb43434343cbcbcbcb43434343
    // edededed65656565edededed65656565
    // -f-f-f-f878787870f0f0f0f87878787

    CubeXLineBitwise res;
    //res._98109810 = _98109810;
    //res._a921a921 = _a921a921;
    //res._ba32ba32 = _ba32ba32;
    //res._cb43cb43 = _cb43cb43;
    //res._dc54dc54 = _dc54dc54;
    //res._ed65ed65 = _ed65ed65;
    //res._fe76fe76 = _fe76fe76;
    //res.__f870f87 = __f870f87;
    res.cubes[0] = _98109810;
    res.cubes[1] = _a921a921;
    res.cubes[2] = _ba32ba32;
    res.cubes[3] = _cb43cb43;
    res.cubes[4] = _dc54dc54;
    res.cubes[5] = _ed65ed65;
    res.cubes[6] = _fe76fe76;
    res.cubes[7] = __f870f87;
    return res;
}
//uint4 bitwiseLastHalfCubeXLine_( uint4 y0z0r, uint4 y0z1r, uint4 y1z0r, uint4 y1z1r )
uint bitwiseLastHalfCubeXLine_( uint y0z0r, uint y0z1r, uint y1z0r, uint y1z1r )
{
    return ( y0z0r & 1 ) << 25 | ( y0z1r & 1 ) << 27 | ( y1z0r & 1 ) << 29 | ( y1z1r & 1 ) << 31;
    //return ( y0z0r & 1 ) << 1 | ( y0z1r & 1 ) << 3 | ( y1z0r & 1 ) << 5 | ( y1z1r & 1 ) << 7;
}



uint toCubeInstance(uint ix, uint iy, uint iz, uint gridId, uint cubeId)
{
    return iz << 27 | iy << 22 | ix << 17 | gridId << 8 | cubeId;
    //return ((iz & 0x1f) << 27) | ((iy & 0x1f) << 22) | ((ix & 0x1f) << 17) | ((gridId & 0x1ff) << 8) | (cubeId & 0xff);
}


//struct GridInstruction
//{
//    float3 position;
//    int dynamic_grid_id;
//    int static_grid_ids[2][2][2];
//};
//StructuredBuffer<GridInstruction> grid_instructions;

StructuredBuffer<int4> BoneVectorBuffer;
int	VectorLengthPerInstance;
int BoneVectorOffset;

static const uint4 element_mask_table[] =
{
	//{1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1}
	{1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1}// 00, 01, 10, 11
};

int toIndex(int igrid, int overx, int iy, int iz)
{
    const int overy = iy >> 5;
    const int overz = iz >> 5;
    const int _iy = iy & 0x1f;
    const int _iz = iz & 0x1f;

    //const int _gid = grid_instructions[igrid].static_grid_ids[overx][overy][overz];
    const int4 pack4 = BoneVectorBuffer[igrid + overx];
    const int _gid = dot(pack4, element_mask_table[overy << 1 + overz]);

    if (_gid == -1) return -1;

    const int g = _gid * 32 * 32;
    const int z = _iz * 32;
    const int y = _iy;
    return g + z + y;
}







[numthreads(1, 32, 32)]
void CSMain (uint3 id : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
    //const int igrid = gid.x;// instrucction grid id
    const int igrid = BoneVectorOffset + VectorLengthPerInstance * gid.x + 1;// 1 はポジション分

    const int i00 = toIndex(igrid, 0, id.y + 0, id.z + 0); if (i00 == -1) return;
    const int i01 = toIndex(igrid, 0, id.y + 0, id.z + 1); if (i01 == -1) return;
    const int i10 = toIndex(igrid, 0, id.y + 1, id.z + 0); if (i10 == -1) return;
    const int i11 = toIndex(igrid, 0, id.y + 1, id.z + 1); if (i11 == -1) return;

    const uint y0z0 = dotgrids[i00];
    const uint y0z1 = dotgrids[i01];
    const uint y1z0 = dotgrids[i10];
    const uint y1z1 = dotgrids[i11];

    const CubeXLineBitwise cubes = bitwiseCubesXLine_(y0z0, y0z1, y1z0, y1z1);

    [unroll]
    for (uint i = 0; i < 7; i++)
    {
        const uint pack4cubes = cubes.cubes[i];

        [unroll]
        for (uint j = 0; j < 4; j++)
        {
            const uint shift = j * 8;
            const uint cube = pack4cubes >> shift & 0xff;

            if (cube == 0) continue;

            const uint instance = toCubeInstance(shift + i, id.y, id.z, igrid, cube);
            cube_instances.Append(instance);
        }
    }
    
    const uint pack4cubes = cubes.cubes[7];

    [unroll]
    for (uint j = 0; j < 3; j++)
    {
        const uint shift = j * 8;
        const uint cube = pack4cubes >> shift & 0xff;

        if (cube == 0) continue;

        const uint instance = toCubeInstance(shift + 7, id.y, id.z, igrid, cube);
        cube_instances.Append(instance);
    }

    const int i00r = toIndex(igrid, 1, id.y + 0, id.z + 0); if (i00r == -1) return;
    const int i01r = toIndex(igrid, 1, id.y + 0, id.z + 1); if (i01r == -1) return;
    const int i10r = toIndex(igrid, 1, id.y + 1, id.z + 0); if (i10r == -1) return;
    const int i11r = toIndex(igrid, 1, id.y + 1, id.z + 1); if (i11r == -1) return;
    
    const uint y0z0r = dotgrids[i00r];
    const uint y0z1r = dotgrids[i01r];
    const uint y1z0r = dotgrids[i10r];
    const uint y1z1r = dotgrids[i11r];
    
    const uint cube_r = bitwiseLastHalfCubeXLine_(y0z0r, y0z1r, y1z0r, y1z1r);

    const uint shift = 3 * 8;
    const uint cube = (pack4cubes | cube_r) >> shift & 0xff;
    //const uint cube = pack4cubes >> shift & 0xff | cube_r;

    if (cube == 0) return;

    const uint instance = toCubeInstance(shift + 7, id.y, id.z, igrid, cube);
    cube_instances.Append(instance);
}
